{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Redefine how you interact with your code</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Vision is a modern, lightweight command bar built for all Roblox experiences\u2014from massive games without thousands of players and dozens of developers, to small personal projects shared among friends. It\u2019s designed to feel native, intuitive, and powerful right out of the box.</p> <p>With Vision, you can easily build commands and apps that trigger functions on the server and client, open custom menus, reward players with coins, run admin or developer utilities, and so much more.</p> <p>Vision was built to be extensible, adaptable, and modular; add custom behaviors and integrations, use it in a live game, testing experience, or studio, and keep your code organized, scalable, and maintainable.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p> Modern, Lightweight</p> <p>Visions user interface was thoughtfully designed to be both beautiful and efficient. Whether you're a first time user or an expert, the layout and intuitive navigation makes it easy for everyone.</p> </li> <li> <p> Extensible API</p> <p>Vision has a extensible API for developers who want full control without the hassle. Whether you're adding custom commands, or integrating with external systems, the API provides flexibility and structure you need to expand functionality effortlessly.</p> </li> <li> <p> Built with Fusion</p> <p>Visions user interface is fully coded with Fusion for a fast, reliable, and optimized experience. Every element is designed to respond smoothly and efficiently, making interactions seamless.</p> </li> <li> <p> Open Source, MIT</p> <p>Vision is available on GitHub and licensed under the MIT License. Allowing you to freely use, modify, and distribute it in both personal and commercial projects.</p> </li> </ul>"},{"location":"Guide/","title":"Guide","text":"<p>Before you dive in, this guide assumes you already have some foundational knowledge.</p> <p>Vision Is Still In Active Development</p> <p>We're committed to keeping Vision stable, secure, and production-ready. That said, the design and API are still evolving.</p> <p>You may encounter breaking changes as we continue improving the library. These changes could require you to adapt your codebase. While we try to avoid major overhauls, they may occasionally happen \u2014 and if they do, we\u2019ll communicate them clearly in advance.</p> <p>Expect updates that add, change, or remove features. Our goal is to provide a powerful and intuitive API, even if it means making tough decisions along the way.</p>"},{"location":"Guide/#what-you-should-know","title":"What You Should Know","text":"<ol> <li>Familiar with Roblox Studio or Visual Studio Code, along with common extensions such as Wally.</li> <li>Knowledge in Luaudf \u2014 we recommend at least understanding the basics of object-oriented programming.</li> <li>If you plan to add custom UI features, we recommend learning Fusion 0.3. We\u2019ll cover some basics, but prior knowledge will help.</li> </ol>"},{"location":"Guide/Commands/","title":"Commands","text":"<p>No commands are registered by default. To learn how to enable built in commands, see Default Commands.</p> <p>To create a command, create a <code>ModuleScript</code> into a folder which returns a command definition:</p> <p>invisible.lua<pre><code>return {\n    Name = \"invisible\",\n    Aliases = { \"invis\" },\n\n    UndoName = \"visible\"\n    UndoAliases = { \"vis\" }\n\n    Description = \"Makes a player or a group of players invisible\",\n    UndoDescription = \"Makes a player or a group of players visible\",\n\n    App = \"Basic Commands\",\n    Arguments = {\n        {\n            Name = \"players\",\n            Type = \"players\",\n            Description = \"The players to make invisible\",\n            -- Custom function that the \"players\" type has\n            ForEachClient = function(player)\n                -- e.g. render player half-invisible on the client\n            end\n        }\n    }\n}\n</code></pre> Server logic belongs in its own <code>ModuleScript</code> with the same name but with a \"Server\" suffix, which returning a single function.</p> invisibleServer.lua<pre><code>return function(context, players)\n    -- Arguments already validated and type-checked!\n    -- Optional args = nil or an empty table if listable.\n    for index, player in players do\n        -- Make the player invisible on the server\n    end\nend\n</code></pre> Server Functions Are Never Exposed to the Client <p>You can safely include secrets (e.g., webhook URLS) here without worrying if it will be exposed to the client.</p>"},{"location":"Guide/Commands/#wrapping-functions","title":"Wrapping Functions","text":"<p>Functions can be \"wrapped\" and turned into a command:</p> wrapping.lua<pre><code>local function notifyPlayer(player, title, text)\n    Vision:RunCommand(\"notify\", player, title, text)\nend\n\nVision:Wrap(notifyPlayer, {\"players\", \"string\", \"string\"})\n</code></pre> <p>Wrapped functions will automatically inherit the name of the function.</p> What about Anonymous Functions? <p>If the wrapped function is anonymous,  the first item inside of the arguments table should be the command name.</p> <pre><code>Vision:Wrap(function(soundId)\n    -- Play the sound...\nend, {\"playSound\", \"assetId\"})\n</code></pre> <p>To add names and descriptions to the types, make them a table:</p> \u00a0\u00a0 Array Formatting\u00a0\u00a0 Dictionary Formatting\u00a0\u00a0 Quick Formatting <p>You can use an array to format your arguments, the only required parameter for each argument is <code>Type</code> (#3):</p> <pre><code>local arguments = {\n    {\n        [1] = \"Name\",\n        [2] = \"Description\",\n        [3] = \"Type\"\n    },\n    {\n        \"Speed\",\n        \"The speed to give the players\",\n        \"number\"\n    }\n}\n</code></pre> <p>You can also use a dictionary to format your arguments, the only required parameter for each argument is <code>Type</code>:</p> <pre><code>local arguments = {\n    {\n        Name = \"Name\",\n        Description = \"Description\",\n        Type = \"Type\"\n    },\n    {\n        Name = \"Speed\",\n        Description = \"The speed to give the players\",\n        Type = \"number\"\n    }\n}\n</code></pre> <p>If you don't need to set the name or description of a command, you can do so like this: <pre><code>local arguments = {\"string\", \"numbers\", \"player\"}\n</code></pre></p>"},{"location":"Guide/Commands/#command-data","title":"Command Data","text":"<p>To gather client-side data (mouse position, device, etc.) define <code>DataType</code>, and <code>Data</code>, for example:</p> command.lua<pre><code>DataType = \"CFrame\" -- or a table (e.g. {MousePos = \"CFrame\", MouseHitPos = \"CFrame\"})\nData = function(localPlayer)\n    return localPlayer:GetMouse().Hit.Position\nend\n</code></pre> <p>This data is then available for the server in <code>context.Data</code>.</p>"},{"location":"Guide/Commands/#execution-order","title":"Execution Order","text":"<ol> <li><code>BeforeRun</code> client hook.</li> <li><code>Data</code> function on the client.</li> <li><code>ClientRun</code> function on the client.</li> <li><code>BeforeRun</code> server hook. *</li> <li><code>ServerRun</code> (if present) *</li> <li><code>AfterRun</code> hook on server *</li> <li><code>AfterRun</code> hook on client.</li> </ol> <p>* Only runs if <code>ClientRun</code> isn't present or returns <code>nil</code>.</p>"},{"location":"Guide/Commands/#default-commands","title":"Default Commands","text":"<p>If you run <code>Vision:RegisterBuiltInCommands()</code> the following commands and apps will be registered:</p> <p>App: <code>Vision</code></p> <ul> <li><code>toast state (player)</code></li> <li><code>hint message (player)</code></li> </ul> <p>If you want to blacklist certain built-in commands, <code>Vision:RegisterBuiltInCommands()</code> has a <code>filter</code> parameter:</p> <pre><code>local blacklistedCommands = {\"toast\", \"hint\"}\n\nVision:RegisterBuiltInCommands(function(command)\n    -- return true to register, false to skip\n    return blacklistedCommands[command.Name] == nil\nend)\n</code></pre>"},{"location":"Guide/Commands/#argument-aliases","title":"Argument Aliases","text":"<p>Instead of having to type out the entire argument, you can use the following aliases as a shorthand:</p> Alias Meaning Requirements . Default value <code>Default</code> function present * All possible values <code>Listable</code> and <code>All</code>/<code>Autocomplete</code> functions present ** All possible values except the default value <code>Listable</code>, <code>All</code>/<code>Autocomplete</code>, and <code>Default</code> functions present ? A random value picked from all possible values <code>All</code>/<code>Autocomplete</code> function present ?n A number (n) of random values picked from all possible values <code>Listable</code> and <code>All</code>/<code>Autocomplete</code>h functions present ! The last value(s) used The type has been used before <p>Combining Aliases</p> <p>You can combine aliases with a + or a - to add/remove items. (e.g. <code>?-.</code> picks a random value excluding the default value.)</p>"},{"location":"Guide/InstallingVision/","title":"Installing Vision","text":""},{"location":"Guide/InstallingVision/#installing-via-wally","title":"Install via Wally recommended","text":"<p>Vision is published as a Wally package and can be installed as a dependency. </p> <ol> <li> <p>Add Vision to your <code>wally.toml</code> dependency list</p> wally.toml<pre><code>[dependencies]\nVision = \"metatablesnow/vision@0.1.0\"\n</code></pre> </li> <li> <p>Install the dependency  inside the terminal    terminal<pre><code>wally install\n</code></pre></p> </li> </ol> <p>This will install Vision to your <code>Packages</code> folder.</p> What is Wally? <p>Wally is a package manager for Roblox, inspired by Cargo and npm. It brings the familiar, community-oriented world of sharing code from other communities into the Roblox ecosystem.</p>"},{"location":"Guide/InstallingVision/#installing-via-roblox","title":"Installing via Roblox","text":"<p>If you are creating a Roblox experience, you can import a roblox model file (<code>.rbxm</code>) containing Vision.</p> <ol> <li>Download the <code>.rbxm</code> file from Visions \"Releases\" page</li> <li>Inside of Roblox Studio, right-click on <code>ReplicatedStorage</code> and select \"Insert from File...\"</li> <li>Select the <code>Vision.rbxm</code> file you downloaded, Vision should now be inside of Replicated Storage</li> </ol> Don't Miss Important Updates! <p>If you aren't using a package manager like Wally, you may miss important updates! We're working hard to make a Roblox package so you can receive auto-update. In the meantime, watch the GitHub repository for releases to be notified when a new release is published.</p>"},{"location":"Guide/InstallingVision/#setup","title":"Setup","text":"<p>Follow the steps below to setup Vision on the server and client:</p> \u00a0\u00a0 Server Setup\u00a0\u00a0Client Setup <p>Inside of a server script, which should be inside of <code>ServerScriptService</code>, you can require Vision, and optionally register the default commands (teleport, kill, etc.), and some useful apps (calculator,  debug, etc.) InitiateVision.server.luau<pre><code>local Vision = require(path.to.Vision)\n\nVision:RegisterBuiltInCommands() -- This runs Vision:RegisterBuiltInApps()\n</code></pre></p> <p>Inside of a client script, you can require Vision and optionally set hotkeys to open Vision. InitiateVision.client.luau<pre><code>local Vision = require(path.to.Vision)\n\nVision:SetHotkeys({\n  {Enum.KeyCode.Ctrl, Enum.KeyCode.R} -- These can be key-combos, or single keys\n})\n</code></pre></p> <p>Thats All!</p> <p>You can now press the hotkeys you assigned, and Vision should appear. Keep reading to learn how to create your own commands, types, and more!</p>"}]}